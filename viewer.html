<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">Joint Movement and Injury Simulation</title>
    <style>

        p{font-size: small;}
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        .back-icon {
           
    display: flex; /* Use flexbox to align children */
    align-items: center; /* Center vertically */
}
.marker-label {
    position: absolute; /* Position it absolutely */
    font-size: x-small; /* Adjust font size as needed */
    color: white; /* Set text color */
    text-align: center; /* Center the text */
    transform: translateY(-5px);
    background-color: #54aaff;
    padding:5px;
    border-radius: 5px;
}



.back-arrow {
    display: inline-block;
    width: 0;
    height: 0;
    border-left: 8px solid transparent; /* Left transparent border */
    border-right: 8px solid transparent; /* Right transparent border */
    border-top: 15px solid white; /* Create the arrow */
    border-bottom: 2px solid transparent;
    transform: rotate(90deg); /* Rotate the arrow */
    margin: 0; /* Ensure no margin */
    padding: 0; /* Ensure no padding */
    vertical-align: middle; /* Align vertically */
   
}

.back-rectangle {
    display: inline-block;
    width: 8px; /* Width of the rectangle */
    height: 6px; /* Height of the rectangle */
    background-color: white; /* Color of the rectangle */
    margin: 0; /* Reduce spacing */
    padding: 0; /* Ensure no padding */
    vertical-align: middle; /* Align vertically */
    border:1px solid white; 
}

    

        header {
            background-color: #007BFF;
            color: white;
            padding: 10px 20px;
            text-align: center;
            display: flex; /* Use Flexbox for layout */
    /* justify-content: space-between; Space between title and button */
    align-items: center; /* Center vertically */
        }
        
        #back-button {
            display:inline-block;
            background-color: #0056b3;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            text-decoration: none;
            align-items: center; /* Center content vertically */
            justify-content: center; /* Center content horizontally */
        }

        #model-title {
            padding: 10px 15px;
            display:inline-block;
        }
        #back-button:hover {
            background-color: #004494;
        }
        .whole-timeline{display: flex; /* Use flexbox for alignment */
    justify-content: center; /* Center buttons horizontally */
   
    padding: 10px; /* Optional padding */
    background-color: #fff; /* Optional background color */
    box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2); /* Optional shadow for separation */
z-index: 1000;}

#timeline-container {
    flex: 1; 
            position: relative; /* Make the container relative */
           
        }



        #timeline {
            width: 100%; /* Full width for the timeline */
            margin: 0; /* Remove default margin */
            position: relative; /* Ensure it is positioned relative to the container */
            z-index: 1; /* Ensure the timeline is below markers */
            height: 5px; /* Height of the timeline */
            background-color: #ccc; /* Timeline color */
            /* margin-top: 10px;
            width: 100%; */
            /* margin-top: 10px; */
        }
        /* .control-button {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            margin: 0 5px;
        } */

        .timeline-wrapper {
            display: flex;
            align-items: center;
    background-color: white; /* Background color for the wrapper */
    padding: 15px; /* Padding around the content */
    border-radius: 5px; /* Rounded corners */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); /* Shadow for depth */
    position: relative; /* Relative positioning for absolute elements */
    max-width: 1200px; /* Optional: Set a max width */
    margin: 20px auto; /* Center the wrapper with some margin */
}

#timeline-value{
    transform: translateY(2px); 
    
    
    
    z-index: 10; /* Ensure it's above other elements */
}

        .two-buttons{
           left: 20px; 
            width:100%;
            display: flex; /* Use flexbox to align buttons */
    flex-direction: row; /* Stack buttons vertically */ position: absolute; /* Position it absolutely */
    
    transform: translateY(2px); /* Center vertically */
    z-index: 10; /* Ensure it's above other elements */
           
        }


        .control-button {
    background-color: #f0f0f0; /* Button color */
    color: white; /* Text color */
    border: none; /* No border */
    padding: 3px 8px; /* Padding for buttons */
    cursor: pointer; /* Pointer on hover */
    border-radius: 5px; /* Rounded corners */
    margin-bottom: 20px; /* Space between buttons */
    transition: background-color 0.3s; /* Smooth transition for hover */
}

.control-button:hover {
    background-color: #eaf4ff; /* Darker background on hover */
}



        .all-control{
            display: flex; /* Use flexbox for alignment */
    justify-content: center; /* Center buttons horizontally */
    
   
        }
        #all {
            display: flex;
            flex-wrap: wrap;
            height: calc(100vh - 100px);
        }
        #viewer-container {
            flex: 1;
            background: #eee;
            margin: 0;
            padding:20px;
            
            
        }
        #controls {
            flex: 1;
            padding: 20px;
           
            text-align: center;
            background-color: white;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
        }


        
        .triangle {
    display: inline-block;
    width: 0;
    height: 0;
    border-left: 5px solid transparent; /* Left transparent border */
    border-right: 5px solid transparent; /* Right transparent border */
    border-top: 10px solid #5a5a5a; /* Change to top to create an upward-pointing triangle */
    transform: rotate(-90deg); /* Rotate the triangle 90 degrees */
}
.double-rectangles{
    display: flex; /* Use flexbox to align rectangles */
    align-items: center; /* Center vertically */
}

.rectangle {
    display: inline-block;
    width: 2px; /* Width of the rectangle */
    height: 10px; /* Height of the rectangle */
    background-color:#5a5a5a; /* Color of the rectangles */
    margin: 0 1px; /* Reduce the spacing between rectangles */
   
}

#close-controls {
    background: none;
    border: none;
    color: #5a5a5a; /* Red color for the close button */
    font-size: 20px; /* Adjust size as needed */
    cursor: pointer;
    position: absolute; /* Positioning */
    top: 10px; /* Adjust top position */
    right: 10px; /* Adjust right position */
    display: none; /* Initially hidden */
}

#toggle-controls {
        display: none; /* Show toggle button */
        margin: 10px; /* Optional spacing */
    }

    .timeline-with-markers {
        width:100%;
    display: flex;
    flex-direction: column; /* Stack elements vertically */
    align-items: center; /* Center items horizontally */
    position: relative; /* Positioning for absolute elements */
}

#markers-container {
    position: absolute; /* Position markers absolutely */
            top: 0; /* Align at the top of the container */
            left: 0; /* Align to the left */
            width: 100%; /* Full width to match the timeline */
            pointer-events: none; /* Prevent markers from capturing events */
}

.marker {
    position: absolute; /* Position markers absolutely */
            top: -10px; /* Adjust as needed to sit above the timeline */
            width: 10px; /* Width of marker */
            height: 10px; /* Height of marker */
            background-color: #54aaff; /* Marker color */
            border-radius: 50%; /* Make them circular */
            pointer-events: auto; /* Allow interaction */
            z-index: 2; /* Ensure markers are above the timeline */
}

.marker-label {
    transition: background-color 0.3s; /* Smooth transition */
}



.marker-label:hover {
    background-color: #358be1; /* Change to the desired color */
}

.marker-label:hover {
    background-color: #358be1; /* Change to the desired color */
}


    @media (min-width: 1099px) {
    #controls {
        display: block; /* Show controls by default */
    }
}
@media (max-width: 1100px) { 
    #controls {
        display: none; /* Hide controls by default */
        position:absolute;
        top:80px;
        padding: 20px;
            text-align: center;
            background-color: white;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
            z-index:1000;
        
    }
   
    #toggle-controls {
        display: block; /* Show toggle button */
        margin: 10px; /* Optional spacing */
    }
}
    
@media (max-width: 500px) {
    header {
        flex-direction: column; /* Stack items vertically */
        align-items: center; /* Center items horizontally */
    }

    #back-button {
        margin-bottom: 10px; /* Add some space between button and title */
    }

    #model-title {
        font-size: 20px; /* Optional: Adjust title size for smaller screens */
    }


    #controls {
        display: none; /* Hide controls by default */
        position:absolute;
        top:80px;
        padding: 20px;
            text-align: center;
            background-color: white;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
        
    }
   
    #toggle-controls {
        display: block; /* Show toggle button */
        margin: 10px; /* Optional spacing */
    }
   
}




        
    </style>
    <script type="importmap"> { 
        "imports": { 
            "three": "/three/build/three.module.js",
            "three/addons/": "/three/examples/jsm/" 
        } 
    } </script> 
</head>
<body>
    <header>
        <a id="back-button" href="#" onclick="goBack()">
            <div class="back-icon">
                <div class="back-arrow"></div>
                <div class="back-rectangle"></div>
            </div>
        </a>
        <h1 id="model-title"></h1>
    </header>
    <div id="all">
        <div id="viewer-container">
<!-- <div class="whole-timeline"> -->
<div class="timeline-wrapper">
    
            
            <div class="timeline-with-markers">

            <div id="markers-container" >

                <!-- Markers will be added here -->
            </div>
            <input type="range" id="timeline" min="0.01" max="100" value="0" step="0.01">
           <br>
           

            </div>

            <div class="all-control">
                <div class="two-buttons">
                    <button class="control-button" id="play-button">
                        <span class="triangle"></span>
                    </button>
                    <p>  &nbsp; </p>
                    <button class="control-button" id="stop-button">
                        <div class="double-rectangles">
                        <div class="rectangle"></div>
                        <div class="rectangle"></div>
                    </div>
                    
                    </button>
                    <p>  &nbsp;&nbsp;&nbsp;</p>
                    <span id="timeline-value">0%</span>
                </div>
        
                   
        
                    </div>




        </div> 

           
           
            <!-- </div>
             -->
            

            <button id="toggle-controls" >Controls</button>

            
            
        </div>

        
        
        <div id="controls">
            <button id="close-controls" >âœ–</button>
            <button id="reset-camera">Reset Camera</button>
            <br><br>
            Animation Speed: 
            <input type="range" id="speed-control" min="0.01" max="1" value="0.5" step="0.01">
            <span id="speed-display">0.5x</span>
            <br>
            Ambient Light Intensity: 
            <input type="range" id="ambient-light-control" min="0" max="5" value="1" step="0.1">
            <span id="ambient-light-display">1</span>
            <br>
            <br>
            <p style="font-size: smaller; text-align: center;">For mobile devices, one finger to rotate, two finger to pan, pinch to zoom in/out.
                <br><br>For computer, left mouse button to rotate, right mouse button to pan, scroll middle mouse button to zoom.</p>
            
        
    </div>
    <div><p></p></div>
   
    <script type="module">
        window.goBack = function() {
            const urlParams = new URLSearchParams(window.location.search);
            const jointType = urlParams.get('joint'); // Get the joint type from the URL
            let menuPage = 'menu.html';

            if (jointType) {
                menuPage = `menu.html?joint=${jointType.toLowerCase()}`;
            }

            window.location.href = menuPage;
        };

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        let scene, camera, renderer, controls, mixer, clock;
        let animationSpeed = 0.5;
        let initialCameraPosition, initialCameraRotation;
        let totalDuration = 1; // Store total duration of the animation
        let modelCenter = new THREE.Vector3();
        let isPlaying = false; // Track whether animation is playing
        let smaller=false;
        let previousTime = 0; // Initialize previousTime
        const minDistance = 0.5; // Minimum distance from the object

        
        window.onload = function() {
    setMarkerPositions(); // Call it to set initial positions on load
};
        function init(modelFile, modelName) {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0.5, 3);

            initialCameraPosition = camera.position.clone();
            initialCameraRotation = camera.rotation.clone();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.setSize(window.innerWidth * 0.8, window.innerHeight * 0.8);
            //document.getElementById('viewer-container').appendChild(renderer.domElement);
            document.getElementById('viewer-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;
            controls.enablePan = true;
            controls.panSpeed = 1.0;
            controls.minDistance = minDistance; //zoom distance
            const ambientLight = new THREE.AmbientLight(0xffffff, 1);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            clock = new THREE.Clock();

            const loader = new FBXLoader();
            const urlParams = new URLSearchParams(window.location.search);

            loader.load(modelFile, (object) => {
                mixer = new THREE.AnimationMixer(object);
                 
                if (object.animations && object.animations.length > 0) {
                    const action = mixer.clipAction(object.animations[0]);
                    action.play();
                    totalDuration = action.getClip().duration;
                    document.getElementById('timeline').max = totalDuration;
                }
                // Fix the comparison operator
                if (urlParams.get('joint') === 'ankle' && urlParams.get('choice') === 'injury') {
                    object.scale.set(0.005, 0.005, 0.005);
                   
                    if(urlParams.get('modelName') === 'Inversion')
                    {object.position.z = 2.5;
                        object.position.x = 2;  
                    }
                    if(urlParams.get('modelName') === 'Eversion Abduction')
                    {object.position.z = -1.5;
                       // object.position.x = 0.5;
                       // object.position.y = 0.2; // Lower the model's y position
                        object.rotation.y = -0.1;
                       // object.scale.set(0.0045, 0.0045, 0.0045);
                                        
                       
                    }

                    if(urlParams.get('modelName') === 'Eversion')
                    { object.position.y = 0.3;
                        object.rotation.y = 0.1;
                        object.rotation.z = -0.025;
                        
                      
                       
                    }
                    if(urlParams.get('modelName') === 'Eversion Plantarflexion')
                     {
                         object.position.y = 0.7;
                    //     object.position.x = -0.5;
                        object.rotation.y = 0.25;
                     //object.position.z = -1;
                      object.scale.set(0.005, 0.005, 0.005);
                        
                    }

                    if(urlParams.get('modelName') === 'Inversion Abduction Dorsiflexion')
                    { 
                        object.scale.set(0.0045, 0.0045, 0.0045);
                        object.position.z = -1;
                        

                        
                        
                    }

                } else {
                    object.scale.set(0.01, 0.01, 0.01);
                    object.position.y = -0.3; // Lower the model's y position
                    if(urlParams.get('modelName') === 'ACL Injury')
                    { 
                        object.scale.set(0.007, 0.007, 0.007);
                        object.position.z = -1;                     
                        
                    }
                    if(urlParams.get('modelName') === 'Posterior Dislocation')
                    { 
                       // object.scale.set(0.007, 0.007, 0.007);
                        object.position.z = -3;                     
                        
                    }

                }
                // Traverse the loaded object
    object.traverse((child) => {
        child.frustumCulled = false; // Disable frustum culling
        if (child.isMesh) {
            // Check if the mesh has one or multiple materials
            if (Array.isArray(child.material)) {
                // If there are multiple materials
                child.material.forEach((material) => {
                    material.depthTest = true; // Enable depth testing
                    material.transparent = false; // Set to true if transparency is needed
                });
            } else {
                // If there is a single material
                child.material.depthTest = true; // Enable depth testing
                child.material.transparent = false; // Set to true if transparency is needed
            }
        }
    });
                  // Adjust the position of the model
                
                scene.add(object);
            }, undefined, (error) => {
                console.error('An error occurred while loading the FBX model:', error);
            });

            window.addEventListener('resize', onWindowResize, false);
            animate();
            setMarkerPositions();
            checkCameraDistance();

            document.getElementById('model-title').textContent = modelName;
            document.title = modelName;

            document.getElementById('ambient-light-control').addEventListener('input', function () {
                const intensity = parseFloat(this.value);
                ambientLight.intensity = intensity;
                document.getElementById('ambient-light-display').textContent = intensity.toFixed(1);
            });
            
            // Timeline control event
            const timeline = document.getElementById('timeline');
            timeline.addEventListener('input', function () {
                const time = parseFloat(this.value);
                if (mixer) {
                    mixer.setTime(time);
                }
                const percentage = (time / totalDuration) * 100;
                document.getElementById('timeline-value').textContent = `${Math.round(percentage)}%`;
            });

            // Play button event
            document.getElementById('play-button').addEventListener('click', function() {
                isPlaying = true; // Set isPlaying to true
            });

            // Stop button event
            document.getElementById('stop-button').addEventListener('click', function() {
                isPlaying = false; // Set isPlaying to false
            });
        }



        const urlParams = new URLSearchParams(window.location.search);
let specialMoments = {
    shoulder: {
        "Anterior Dislocation": [
            { time: 31, label: "Injury<br>Start" },
            { time: 51, label: "Injury<br>End" }
        ], 
        "Posterior Dislocation": [
            { time: 77, label: "Injury<br>Start" },
            { time: 100, label: "Injury<br>End" }
        ]
    }, 
    elbow: {
        "Valgus Overload": [
            { time: 40, label: "Injury<br>Start" },
            { time: 57, label: "Injury<br>End" }
        ], 
        "Elbow Fully Extended": [
            { time: 59, label: "Injury<br>Start" },
            { time: 70, label: "Injury<br>End" }
        ],
    },

    knee: {
        "ACL Injury": [
            { time: 60, label: "Injury<br>Start" },
            { time: 71, label: "Injury<br>End" }
        ], 
        
    },

    ankle: {
        "Eversion": [
            { time: 61, label: "Injury<br>Start" },
            { time: 74, label: "Injury<br>End" }
        ], 
        "Eversion Abduction": [
            { time: 64, label: "Injury<br>Start" },
            { time: 85, label: "Injury<br>End" }
        ],

        "Eversion Dorsiflexion": [
            { time: 52, label: "Injury<br>Start" },
            { time: 74, label: "Injury<br>End" }
        ],

        "Eversion Plantarflexion": [
            { time: 11, label: "Injury<br>Start" },
            { time: 38, label: "Injury<br>End" }
        ],

        "Inversion": [
            { time: 61, label: "Injury<br>Start" },
            { time: 82, label: "Injury<br>End" }
        ],

        "Inversion Abduction Dorsiflexion": [
            { time: 69, label: "Injury<br>Start" },
            { time: 92, label: "Injury<br>End" }
        ],

        "Inversion Adduction Plantarflexion": [
            { time: 62, label: "Injury<br>Start" },
            { time: 88, label: "Injury<br>End" }
        ],

        "Inversion Dorsiflexion": [
            { time: 54, label: "Injury<br>Start" },
            { time: 74, label: "Injury<br>End" }
        ],
    }



};

let totaltimeline = 100; // Example total duration for calculation



function hasSpecialMoments(bodyPart, name) {
    if (!specialMoments[bodyPart]) {
        console.warn(`No special moments found for body part: ${bodyPart}`);
        return false;
    }
    if (!specialMoments[bodyPart][name]) {
        console.warn(`No special moments found for model: ${name} in body part: ${bodyPart}`);
        return false;
    }
    return true;
}


function setMarkerPositions() {
    const markersContainer = document.getElementById('markers-container');
    
    
    const timeline = document.getElementById('timeline');
    const timelineWidth = timeline.offsetWidth;

    markersContainer.innerHTML = ''; // Clear existing markers

    if (hasSpecialMoments(urlParams.get('joint'),urlParams.get('modelName') )){
        let moments = specialMoments[urlParams.get('joint')][urlParams.get('modelName')];
        moments.forEach(moment => {
            // Create marker
            const marker = document.createElement('div');
            marker.className = 'marker';
           

            // Calculate position based on total duration
            const positionPercentage = (moment.time / totaltimeline) * 100;
            const positionPixels = (positionPercentage / 100) * timelineWidth;

            // Set marker position
            marker.style.left = `${positionPixels}px`;
           // marker.title = moment.label;

            // Create label for the marker
            const label = document.createElement('div');
            label.className = 'marker-label'; // Add a class for styling
            label.innerHTML = moment.label; // Set the text to the marker's label
            label.style.position = 'absolute'; // Position it absolutely
            label.style.left = `${positionPixels- (positionPercentage / 100) * timelineWidth*0.005}px`;
            label.style.top = `${-marker.clientHeight-32}px`; // Adjust this value to position it below the marker
            label.style.zIndex = '10'; // Ensure label is on top
            label.style.pointerEvents = 'auto'; // Ensure pointer events are enabled
            marker.style.left = `${positionPixels-(positionPercentage / 100) * timelineWidth*0.005}px`;
            //marker.title = moment.label;

            // Function to update the mixer and timeline
            const updateTimeline = () => {
                const timeInSeconds = (moment.time / 100) * totalDuration; // Convert time to seconds
                if (mixer) {
                    mixer.setTime(timeInSeconds); // Update the mixer with the new time
                    document.getElementById('timeline').value = (moment.time / 100) * totalDuration; // Update the timeline input value
                    document.getElementById('timeline-value').textContent = `${moment.time}%`; // Update displayed percentage
                } else {
                    console.error('Mixer is not defined');
                }
            };

            // Add click event to the marker
            marker.addEventListener('click', () => {
                console.log(`Marker clicked: ${moment.label} at time: ${moment.time}`);
                
                updateTimeline(); // Call the update function
            });

            // Add click event to the label
            label.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent the click from bubbling up to the marker
                console.log(`Label clicked: ${moment.label} at time: ${moment.time}`);
                console.log(`marker height: ${marker.clientHeight} at time: ${moment.time}`);
                updateTimeline(); // Call the update function
            });

            // Append marker and label to the container
            markersContainer.appendChild(marker);
            markersContainer.appendChild(label);
        });
    } else {
        console.log('No moments found for the specified joint and model.');
    }
}

// Call setMarkerPositions on initial load
setMarkerPositions();

// Add event listener for window resize
// window.addEventListener('resize', setMarkerPositions);
window.addEventListener('resize', () => {
    setMarkerPositions(); // Call this to update markers
    onWindowResize(); // Adjust the camera and renderer
});

const timeline = document.getElementById('timeline');
timeline.addEventListener('input', function () {
    const time = parseFloat(this.value);
    if (mixer) {
        mixer.setTime(time);
    }
    const percentage = (time / totalDuration) * 100;
    document.getElementById('timeline-value').textContent = `${Math.round(percentage)}%`;

    // Update markers' positions
    setMarkerPositions();
});


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth * 0.8, window.innerHeight * 0.8);
        }
        
        
        function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    if (mixer && mixer._actions.length > 0) {
        const action = mixer._actions[0];
        if (isPlaying) {
            mixer.update(delta * animationSpeed);

            // Only update the UI if the current time has changed significantly
            const currentTime = action.time;
            if (currentTime !== previousTime) { // Store previousTime at a higher scope
                document.getElementById('timeline').value = currentTime;
                const percentage = (currentTime / totalDuration) * 100;
                document.getElementById('timeline-value').textContent = `${Math.round(percentage)}%`;
                previousTime = currentTime; // Update previousTime
            }

            // Check if the animation has ended
            if (currentTime >= totalDuration) {
                isPlaying = false; // Stop playing
                document.getElementById('timeline').value = 0;
                document.getElementById('timeline-value').textContent = '0%';
            }
        }
    }
    controls.update();
    checkCameraDistance();
    renderer.render(scene, camera);

            // Prevent camera from going inside the object
           
}

function checkCameraDistance() {
    // Create a bounding box for the object
    const box = new THREE.Box3().setFromObject(scene.children[0]); // Assuming the first child is your model

    // Calculate the bounding sphere from the bounding box
    const sphere = new THREE.Sphere();
    box.getBoundingSphere(sphere); // Get the bounding sphere

    // Calculate the distance from the camera to the sphere center
    const distanceToCenter = camera.position.distanceTo(sphere.center);

    // If the camera is too close, adjust its position
    if (distanceToCenter < minDistance + sphere.radius) {
        // Calculate the direction from the sphere center to the camera
        const direction = camera.position.clone().sub(sphere.center).normalize();
        // Move the camera to be minDistance + sphere.radius away from the sphere center
        camera.position.copy(sphere.center).add(direction.multiplyScalar(minDistance + sphere.radius));
    }
}


        
        document.addEventListener("DOMContentLoaded", function() {
            const urlParams = new URLSearchParams(window.location.search);
            const modelFile = urlParams.get('modelFile') || 'default.fbx'; // Replace with your model file
            const modelName = urlParams.get('modelName') || '3D Model Viewer';
            

            document.getElementById('speed-control').addEventListener('input', function () {
                animationSpeed = parseFloat(this.value);
                document.getElementById('speed-display').textContent = animationSpeed + "x";
            });

            document.getElementById('reset-camera').addEventListener('click', function() {
                camera.position.copy(initialCameraPosition);
                camera.rotation.copy(initialCameraRotation);
                controls.target.copy(modelCenter);
                controls.update();
            });
            initTouchControls();
        
            init(modelFile, modelName);
        });
        function initTouchControls() {
    let touchStartX = 0;
    let touchStartY = 0;
    let isDragging = false;
    let previousDistance = null;

    const viewerContainer = document.getElementById('viewer-container');

    viewerContainer.addEventListener('touchstart', function(event) {
        if (event.touches.length === 1) {
            isDragging = true;
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }
    });

    viewerContainer.addEventListener('touchmove', function(event) {
        if (isDragging && event.touches.length === 1) {
            const deltaX = event.touches[0].clientX - touchStartX;
            const deltaY = event.touches[0].clientY - touchStartY;

            // // Rotate the model using the OrbitControls' methods
            // controls.rotateLeft(deltaX * 0.005); // Adjust sensitivity as needed
            // controls.rotateUp(deltaY * 0.005); // Adjust sensitivity as needed

            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        } else if (event.touches.length === 2) {
            const touch1 = event.touches[0];
            const touch2 = event.touches[1];

            const distX = touch2.clientX - touch1.clientX;
            const distY = touch2.clientY - touch1.clientY;
            const distance = Math.sqrt(distX * distX + distY * distY);

            // Pinch to zoom
            if (previousDistance) {
                const deltaDistance = distance - previousDistance;
                controls.dollyIn(Math.pow(0.95, deltaDistance * 0.1)); // Zoom in
                controls.dollyOut(Math.pow(0.95, -deltaDistance * 0.1)); // Zoom out
            }

            previousDistance = distance; // Store the current distance for the next move

            // Pan the model with two fingers
            const midPointX = (touch1.clientX + touch2.clientX) / 2;
            const midPointY = (touch1.clientY + touch2.clientY) / 2;

            if (this.previousMidPoint) {
                const deltaMidX = midPointX - this.previousMidPoint.x;
                const deltaMidY = midPointY - this.previousMidPoint.y;

                // Update controls to pan
                controls.pan(new THREE.Vector3(deltaMidX * 0.01, -deltaMidY * 0.01, 0)); // Adjust sensitivity as needed
            }

            this.previousMidPoint = { x: midPointX, y: midPointY }; // Store the current midpoint for the next move
        }
    });

    viewerContainer.addEventListener('touchend', function(event) {
        if (event.touches.length < 2) {
            previousDistance = null; // Reset distance tracking
            this.previousMidPoint = null; // Reset midpoint tracking
        }
        if (event.touches.length === 0) {
            isDragging = false; // Reset dragging state
        }
    });
}
        document.getElementById('toggle-controls').addEventListener('click', function() {
    const controlsDiv = document.getElementById('controls');
    const closeButton = document.getElementById('close-controls');

    // Only toggle controls if the screen width is less than 1100px
    if (window.innerWidth < 1100) {
        if (controlsDiv.style.display === 'none' || controlsDiv.style.display === '') {
            controlsDiv.style.display = 'block'; // Show controls
            closeButton.style.display = 'block'; // Show close button
            controlsDiv.style.marginTop = '10px'; // Optional: add space below the button
        } else {
            controlsDiv.style.display = 'none'; // Hide controls
            closeButton.style.display = 'none'; // Hide close button
        }
    }
});

// Close button functionality
document.getElementById('close-controls').addEventListener('click', function() {
    const controlsDiv = document.getElementById('controls');
    controlsDiv.style.display = 'none'; // Hide controls
    this.style.display = 'none'; // Hide close button
});
    </script>
</body>
</html>