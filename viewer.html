<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">Joint Movement and Injury Simulation</title>
    <style>

        p{font-size: small;}
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
        }

        .back-icon {
           
    display: flex; /* Use flexbox to align children */
    align-items: center; /* Center vertically */
}

.back-arrow {
    display: inline-block;
    width: 0;
    height: 0;
    border-left: 8px solid transparent; /* Left transparent border */
    border-right: 8px solid transparent; /* Right transparent border */
    border-top: 15px solid white; /* Create the arrow */
    border-bottom: 2px solid transparent;
    transform: rotate(90deg); /* Rotate the arrow */
    margin: 0; /* Ensure no margin */
    padding: 0; /* Ensure no padding */
    vertical-align: middle; /* Align vertically */
   
}

.back-rectangle {
    display: inline-block;
    width: 8px; /* Width of the rectangle */
    height: 6px; /* Height of the rectangle */
    background-color: white; /* Color of the rectangle */
    margin: 0; /* Reduce spacing */
    padding: 0; /* Ensure no padding */
    vertical-align: middle; /* Align vertically */
    border:1px solid white; 
}

    

        header {
            background-color: #007BFF;
            color: white;
            padding: 10px 20px;
            text-align: center;
            display: flex; /* Use Flexbox for layout */
    /* justify-content: space-between; Space between title and button */
    align-items: center; /* Center vertically */
        }
        
        #back-button {
            display:inline-block;
            background-color: #0056b3;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            text-decoration: none;
            align-items: center; /* Center content vertically */
            justify-content: center; /* Center content horizontally */
        }

        #model-title {
            padding: 10px 15px;
            display:inline-block;
        }
        #back-button:hover {
            background-color: #004494;
        }
        .whole-timeline{display: flex; /* Use flexbox for alignment */
    justify-content: center; /* Center buttons horizontally */
   
    padding: 10px; /* Optional padding */
    background-color: #fff; /* Optional background color */
    box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2); /* Optional shadow for separation */
z-index: 1000;}
        #timeline {
            width: 100%;
            /* margin-top: 10px; */
        }
        /* .control-button {
            background-color: #007BFF;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            margin: 0 5px;
        } */
        .control-button {
    background-color: #ffffff;
    color: white;
    border: none;
    width: 15px; /* Fixed width */
    height: 15px; /* Fixed height */
    display: flex; /* Use flexbox for alignment */
    align-items: center; /* Center content vertically */
    justify-content: center; /* Center content horizontally */
    cursor: pointer;
    border-radius: 2px;
    margin: 0 5px;
}
        .control-button:hover {
            background-color: rgba(107, 107, 107, 0.395);
        }

        .all-control{
            display: flex; /* Use flexbox for alignment */
    justify-content: center; /* Center buttons horizontally */
   
        }
        #all {
            display: flex;
            flex-wrap: wrap;
            height: calc(100vh - 100px);
        }
        #viewer-container {
            flex: 1;
            background: #eee;
            margin: 0;
            padding:20px;
            
            
        }
        #controls {
            flex: 1;
            padding: 20px;
           
            text-align: center;
            background-color: white;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
        }


        
        .triangle {
    display: inline-block;
    width: 0;
    height: 0;
    border-left: 5px solid transparent; /* Left transparent border */
    border-right: 5px solid transparent; /* Right transparent border */
    border-top: 10px solid #5a5a5a; /* Change to top to create an upward-pointing triangle */
    transform: rotate(-90deg); /* Rotate the triangle 90 degrees */
}
.double-rectangles{
    display: flex; /* Use flexbox to align rectangles */
    align-items: center; /* Center vertically */
}

.rectangle {
    display: inline-block;
    width: 2px; /* Width of the rectangle */
    height: 10px; /* Height of the rectangle */
    background-color:#5a5a5a; /* Color of the rectangles */
    margin: 0 1px; /* Reduce the spacing between rectangles */
   
}

#close-controls {
    background: none;
    border: none;
    color: #5a5a5a; /* Red color for the close button */
    font-size: 20px; /* Adjust size as needed */
    cursor: pointer;
    position: absolute; /* Positioning */
    top: 10px; /* Adjust top position */
    right: 10px; /* Adjust right position */
    display: none; /* Initially hidden */
}

#toggle-controls {
        display: none; /* Show toggle button */
        margin: 10px; /* Optional spacing */
    }

    @media (min-width: 1099px) {
    #controls {
        display: block; /* Show controls by default */
    }
}
@media (max-width: 1100px) { 
    #controls {
        display: none; /* Hide controls by default */
        position:absolute;
        top:80px;
        padding: 20px;
            text-align: center;
            background-color: white;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
        
    }
   
    #toggle-controls {
        display: block; /* Show toggle button */
        margin: 10px; /* Optional spacing */
    }
}
    
@media (max-width: 500px) {
    header {
        flex-direction: column; /* Stack items vertically */
        align-items: center; /* Center items horizontally */
    }

    #back-button {
        margin-bottom: 10px; /* Add some space between button and title */
    }

    #model-title {
        font-size: 20px; /* Optional: Adjust title size for smaller screens */
    }


    #controls {
        display: none; /* Hide controls by default */
        position:absolute;
        top:80px;
        padding: 20px;
            text-align: center;
            background-color: white;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
        
    }
   
    #toggle-controls {
        display: block; /* Show toggle button */
        margin: 10px; /* Optional spacing */
    }
   
}




        
    </style>
    <script type="importmap"> { 
        "imports": { 
            "three": "/three/build/three.module.js",
            "three/addons/": "/three/examples/jsm/" 
        } 
    } </script> 
</head>
<body>
    <header>
        <a id="back-button" href="#" onclick="goBack()">
            <div class="back-icon">
                <div class="back-arrow"></div>
                <div class="back-rectangle"></div>
            </div>
        </a>
        <h1 id="model-title">3D Model Viewer</h1>
    </header>
    <div id="all">
        <div id="viewer-container">
<div class="whole-timeline">
    <div class="all-control">
            <button class="control-button" id="play-button">
                <span class="triangle"></span>
            </button>
            <button class="control-button" id="stop-button">
                <div class="double-rectangles">
                <div class="rectangle"></div>
                <div class="rectangle"></div>
            
            
            </button>

            </div>
            
            <input type="range" id="timeline" min="0" max="100" value="0" step="0.1">
            <span id="timeline-value">0%</span>

            </div>

            <button id="toggle-controls" >Controls</button>

            
        </div>
        
        <div id="controls">
            <button id="close-controls" >âœ–</button>
            <button id="reset-camera">Reset Camera</button>
            <br><br>
            Animation Speed: 
            <input type="range" id="speed-control" min="0.1" max="3" value="1" step="0.1">
            <span id="speed-display">1x</span>
            <br>
            Ambient Light Intensity: 
            <input type="range" id="ambient-light-control" min="0" max="5" value="1" step="0.1">
            <span id="ambient-light-display">1</span>
            <br>
            <br>
            <p style="font-size: smaller; text-align: center;">For mobile devices, one finger to rotate, two finger to pan, pinch to zoom in/out.
                <br><br>For computer, left mouse button to rotate, right mouse button to pan, scroll middle mouse button to zoom.</p>
            
        
    </div>
    <div><p></p></div>

    <script type="module">
        window.goBack = function() {
            const urlParams = new URLSearchParams(window.location.search);
            const jointType = urlParams.get('joint'); // Get the joint type from the URL
            let menuPage = 'menu.html';

            if (jointType) {
                menuPage = `menu.html?joint=${jointType.toLowerCase()}`;
            }

            window.location.href = menuPage;
        };

        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        let scene, camera, renderer, controls, mixer, clock;
        let animationSpeed = 1;
        let initialCameraPosition, initialCameraRotation;
        let totalDuration = 1; // Store total duration of the animation
        let modelCenter = new THREE.Vector3();
        let isPlaying = false; // Track whether animation is playing
        let smaller=false;

        

        function init(modelFile, modelName) {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeeeee);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0.5, 3);

            initialCameraPosition = camera.position.clone();
            initialCameraRotation = camera.rotation.clone();

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.setSize(window.innerWidth * 0.8, window.innerHeight * 0.8);
            //document.getElementById('viewer-container').appendChild(renderer.domElement);
            document.getElementById('viewer-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;
            controls.enablePan = true;
            controls.panSpeed = 1.0;

            const ambientLight = new THREE.AmbientLight(0xffffff, 1);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            clock = new THREE.Clock();

            const loader = new FBXLoader();
            const urlParams = new URLSearchParams(window.location.search);

            loader.load(modelFile, (object) => {
                mixer = new THREE.AnimationMixer(object);
                if (object.animations && object.animations.length > 0) {
                    const action = mixer.clipAction(object.animations[0]);
                    action.play();
                    totalDuration = action.getClip().duration;
                    document.getElementById('timeline').max = totalDuration;
                }
                // Fix the comparison operator
                if (urlParams.get('joint') === 'ankle') {
                    object.scale.set(0.005, 0.005, 0.005);
                   
                    if(urlParams.get('modelName') === 'Inversion')
                    {object.position.z = 2;
                        object.position.x = 2;  
                    }
                    if(urlParams.get('modelName') === 'Eversion Abduction')
                    {object.position.z = -0.5;
                        object.position.x = 0.5;
                        object.position.y = 0.2; // Lower the model's y position
                        object.scale.set(0.0045, 0.0045, 0.0045);
                                        
                       
                    }
                    if(urlParams.get('modelName') === 'Eversion Plantarflexion')
                    { object.position.y = 0.3;
                        object.position.x = -0.5;
                        object.scale.set(0.0045, 0.0045, 0.0045);
                        
                    }

                    if(urlParams.get('modelName') === 'Inversion Abduction Dorsiflexion')
                    { 
                        object.scale.set(0.0045, 0.0045, 0.0045);
                        object.position.z = -1;
                        

                        
                        
                    }

                } else {
                    object.scale.set(0.01, 0.01, 0.01);
                    object.position.y = -0.3; // Lower the model's y position
                }

                  // Adjust the position of the model
    
                scene.add(object);
            }, undefined, (error) => {
                console.error('An error occurred while loading the FBX model:', error);
            });

            window.addEventListener('resize', onWindowResize, false);
            animate();

            document.getElementById('model-title').textContent = modelName;
            document.title = modelName;

            document.getElementById('ambient-light-control').addEventListener('input', function () {
                const intensity = parseFloat(this.value);
                ambientLight.intensity = intensity;
                document.getElementById('ambient-light-display').textContent = intensity.toFixed(1);
            });
            
            // Timeline control event
            const timeline = document.getElementById('timeline');
            timeline.addEventListener('input', function () {
                const time = parseFloat(this.value);
                if (mixer) {
                    mixer.setTime(time);
                }
                const percentage = (time / totalDuration) * 100;
                document.getElementById('timeline-value').textContent = `${Math.round(percentage)}%`;
            });

            // Play button event
            document.getElementById('play-button').addEventListener('click', function() {
                isPlaying = true; // Set isPlaying to true
            });

            // Stop button event
            document.getElementById('stop-button').addEventListener('click', function() {
                isPlaying = false; // Set isPlaying to false
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth * 0.8, window.innerHeight * 0.8);
        }
        
        

        function animate() {
    requestAnimationFrame(animate);
    
    const delta = clock.getDelta();
    if (mixer && mixer._actions.length > 0) { // Check if mixer is defined and has actions
        const action = mixer._actions[0]; // Get the first action (assuming only one animation)
        if (isPlaying) {
            mixer.update(delta * animationSpeed);
            
            // Get the current time of the action
            const currentTime = action.time; // Use the action's time to get the current time
            document.getElementById('timeline').value = currentTime;

            // Calculate percentage for display
            const percentage = (currentTime / totalDuration) * 100;
            document.getElementById('timeline-value').textContent = `${Math.round(percentage)}%`;
            
            // Check if the animation has ended
            if (currentTime >= totalDuration) {
                isPlaying = false; // Stop playing
                // Reset the timeline to the start
                document.getElementById('timeline').value = 0;
                document.getElementById('timeline-value').textContent = '0%';
            }
        }
    }
    controls.update();
    renderer.render(scene, camera);

}
        
        document.addEventListener("DOMContentLoaded", function() {
            const urlParams = new URLSearchParams(window.location.search);
            const modelFile = urlParams.get('modelFile') || 'default.fbx'; // Replace with your model file
            const modelName = urlParams.get('modelName') || '3D Model Viewer';

            document.getElementById('speed-control').addEventListener('input', function () {
                animationSpeed = parseFloat(this.value);
                document.getElementById('speed-display').textContent = animationSpeed + "x";
            });

            document.getElementById('reset-camera').addEventListener('click', function() {
                camera.position.copy(initialCameraPosition);
                camera.rotation.copy(initialCameraRotation);
                controls.target.copy(modelCenter);
                controls.update();
            });
            initTouchControls();
        
            init(modelFile, modelName);
        });
        function initTouchControls() {
    let touchStartX = 0;
    let touchStartY = 0;
    let isDragging = false;
    let previousDistance = null;

    const viewerContainer = document.getElementById('viewer-container');

    viewerContainer.addEventListener('touchstart', function(event) {
        if (event.touches.length === 1) {
            isDragging = true;
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        }
    });

    viewerContainer.addEventListener('touchmove', function(event) {
        if (isDragging && event.touches.length === 1) {
            const deltaX = event.touches[0].clientX - touchStartX;
            const deltaY = event.touches[0].clientY - touchStartY;

            // // Rotate the model using the OrbitControls' methods
            // controls.rotateLeft(deltaX * 0.005); // Adjust sensitivity as needed
            // controls.rotateUp(deltaY * 0.005); // Adjust sensitivity as needed

            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        } else if (event.touches.length === 2) {
            const touch1 = event.touches[0];
            const touch2 = event.touches[1];

            const distX = touch2.clientX - touch1.clientX;
            const distY = touch2.clientY - touch1.clientY;
            const distance = Math.sqrt(distX * distX + distY * distY);

            // Pinch to zoom
            if (previousDistance) {
                const deltaDistance = distance - previousDistance;
                controls.dollyIn(Math.pow(0.95, deltaDistance * 0.1)); // Zoom in
                controls.dollyOut(Math.pow(0.95, -deltaDistance * 0.1)); // Zoom out
            }

            previousDistance = distance; // Store the current distance for the next move

            // Pan the model with two fingers
            const midPointX = (touch1.clientX + touch2.clientX) / 2;
            const midPointY = (touch1.clientY + touch2.clientY) / 2;

            if (this.previousMidPoint) {
                const deltaMidX = midPointX - this.previousMidPoint.x;
                const deltaMidY = midPointY - this.previousMidPoint.y;

                // Update controls to pan
                controls.pan(new THREE.Vector3(deltaMidX * 0.01, -deltaMidY * 0.01, 0)); // Adjust sensitivity as needed
            }

            this.previousMidPoint = { x: midPointX, y: midPointY }; // Store the current midpoint for the next move
        }
    });

    viewerContainer.addEventListener('touchend', function(event) {
        if (event.touches.length < 2) {
            previousDistance = null; // Reset distance tracking
            this.previousMidPoint = null; // Reset midpoint tracking
        }
        if (event.touches.length === 0) {
            isDragging = false; // Reset dragging state
        }
    });
}
        document.getElementById('toggle-controls').addEventListener('click', function() {
    const controlsDiv = document.getElementById('controls');
    const closeButton = document.getElementById('close-controls');

    // Only toggle controls if the screen width is less than 1100px
    if (window.innerWidth < 1100) {
        if (controlsDiv.style.display === 'none' || controlsDiv.style.display === '') {
            controlsDiv.style.display = 'block'; // Show controls
            closeButton.style.display = 'block'; // Show close button
            controlsDiv.style.marginTop = '10px'; // Optional: add space below the button
        } else {
            controlsDiv.style.display = 'none'; // Hide controls
            closeButton.style.display = 'none'; // Hide close button
        }
    }
});

// Close button functionality
document.getElementById('close-controls').addEventListener('click', function() {
    const controlsDiv = document.getElementById('controls');
    controlsDiv.style.display = 'none'; // Hide controls
    this.style.display = 'none'; // Hide close button
});
    </script>
</body>
</html>